// RUN: llzk-opt --llzk-compute-constrain-to-product="root-struct=S1" %s | FileCheck --enable-var-scope %s

module attributes {veridise.lang = "llzk"} {
    struct.def @S1 {
        struct.member @foo : !felt.type
        function.def @compute(%a: !felt.type) -> !struct.type<@S1> {
            %self = struct.new : !struct.type<@S1>
            struct.writem %self[@foo] = %a : !struct.type<@S1>, !felt.type
            function.return %self : !struct.type<@S1>
        }
        function.def @constrain(%self: !struct.type<@S1>, %a: !felt.type)  {
            %foo = struct.readm %self[@foo] : !struct.type<@S1>, !felt.type
            constrain.eq %foo, %a : !felt.type
            function.return
        }
    }
}

// CHECK-LABEL:   struct.def @S1 {
// CHECK-NEXT:      struct.member @[[V0:[0-9a-zA-Z_\.]+]] : !felt.type
// CHECK-NEXT:      function.def @product(%[[A0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@S1> attributes {function.allow_constraint, function.allow_witness} {
// CHECK-NEXT:        %[[V1:[0-9a-zA-Z_\.]+]] = struct.new : <@S1>
// CHECK-NEXT:        struct.writem %[[V1]][@[[V0]]] = %[[A0]] : <@S1>, !felt.type
// CHECK-NEXT:        %[[V2:[0-9a-zA-Z_\.]+]] = struct.readm %[[V1]][@[[V0]]] : <@S1>, !felt.type
// CHECK-NEXT:        constrain.eq %[[V2]], %[[A0]] : !felt.type
// CHECK-NEXT:        function.return %[[V1]] : !struct.type<@S1>
// CHECK-NEXT:      }
// CHECK-NEXT:    }
