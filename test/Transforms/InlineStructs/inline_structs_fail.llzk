// RUN: llzk-opt -split-input-file -llzk-flatten -llzk-inline-structs -verify-diagnostics %s

module attributes {llzk.main = !struct.type<@Main>, veridise.lang = "llzk"} {
  struct.def @ResultOfComputeUnused {
    struct.member @f : !felt.type

    function.def @compute() -> !struct.type<@ResultOfComputeUnused> {
      %self = struct.new : !struct.type<@ResultOfComputeUnused>
      %12 = felt.const 12
      struct.writem %self[@f] = %12 : !struct.type<@ResultOfComputeUnused>, !felt.type
      function.return %self : !struct.type<@ResultOfComputeUnused>
    }

    function.def @constrain(%self: !struct.type<@ResultOfComputeUnused>) {
      %12 = felt.const 12
      %c = struct.readm %self[@f] : !struct.type<@ResultOfComputeUnused>, !felt.type
      constrain.eq %12, %c : !felt.type
      function.return
    }
  }

  struct.def @Main {
    struct.member @fa : !struct.type<@ResultOfComputeUnused>

    function.def @compute() -> !struct.type<@Main> {
      %self = struct.new : !struct.type<@Main>
      // expected-error@+1 {{'function.call' op "@compute" result should be written to a member.}}
      %a = function.call @ResultOfComputeUnused::@compute() : () -> !struct.type<@ResultOfComputeUnused>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %a = struct.readm %self[@fa] : !struct.type<@Main>, !struct.type<@ResultOfComputeUnused>
      function.call @ResultOfComputeUnused::@constrain(%a) : (!struct.type<@ResultOfComputeUnused>) -> ()
      function.return
    }
  }
}
// -----

module attributes {llzk.main = !struct.type<@Main>, veridise.lang = "llzk"} {
  struct.def @ResultOfComputeDoubleUse {
    struct.member @f : !felt.type

    function.def @compute() -> !struct.type<@ResultOfComputeDoubleUse> {
      %self = struct.new : !struct.type<@ResultOfComputeDoubleUse>
      %12 = felt.const 12
      struct.writem %self[@f] = %12 : !struct.type<@ResultOfComputeDoubleUse>, !felt.type
      function.return %self : !struct.type<@ResultOfComputeDoubleUse>
    }

    function.def @constrain(%self: !struct.type<@ResultOfComputeDoubleUse>) {
      %12 = felt.const 12
      %c = struct.readm %self[@f] : !struct.type<@ResultOfComputeDoubleUse>, !felt.type
      constrain.eq %12, %c : !felt.type
      function.return
    }
  }

  struct.def @Main {
    struct.member @fa : !struct.type<@ResultOfComputeDoubleUse>
    struct.member @fb : !struct.type<@ResultOfComputeDoubleUse>

    function.def @compute() -> !struct.type<@Main> {
      %self = struct.new : !struct.type<@Main>
      // expected-error@+1 {{'function.call' op "@compute" result should not be written to more than one member.}}
      %a = function.call @ResultOfComputeDoubleUse::@compute() : () -> !struct.type<@ResultOfComputeDoubleUse>
      // expected-note@+1 {{written here}}
      struct.writem %self[@fa] = %a : !struct.type<@Main>, !struct.type<@ResultOfComputeDoubleUse>
      // expected-note@+1 {{written here}}
      struct.writem %self[@fb] = %a : !struct.type<@Main>, !struct.type<@ResultOfComputeDoubleUse>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %a = struct.readm %self[@fa] : !struct.type<@Main>, !struct.type<@ResultOfComputeDoubleUse>
      function.call @ResultOfComputeDoubleUse::@constrain(%a) : (!struct.type<@ResultOfComputeDoubleUse>) -> ()
      function.return
    }
  }
}
// -----

module attributes {llzk.main = !struct.type<@Main>, veridise.lang = "llzk"} {
  function.def private @temp(%0: !struct.type<@StructAsParamToFreeFunc>)

  struct.def @StructAsParamToFreeFunc {
    struct.member @f1 : !felt.type
    struct.member @f2 : !felt.type

    function.def @compute(%z: !felt.type) -> !struct.type<@StructAsParamToFreeFunc> {
      // expected-error@+1 {{'struct.new' op as argument to a no-body free function is not supported by this pass.}}
      %self = struct.new : !struct.type<@StructAsParamToFreeFunc>
      struct.writem %self[@f1] = %z : !struct.type<@StructAsParamToFreeFunc>, !felt.type
      struct.writem %self[@f2] = %z : !struct.type<@StructAsParamToFreeFunc>, !felt.type
      function.return %self : !struct.type<@StructAsParamToFreeFunc>
    }

    function.def @constrain(%self: !struct.type<@StructAsParamToFreeFunc>, %z: !felt.type) {
      %a = struct.readm %self[@f1] : !struct.type<@StructAsParamToFreeFunc>, !felt.type
      constrain.eq %a, %z : !felt.type
      %b = struct.readm %self[@f2] : !struct.type<@StructAsParamToFreeFunc>, !felt.type
      constrain.eq %b, %z : !felt.type
      function.return
    }
  }

  struct.def @Main {
    struct.member @f2 : !struct.type<@StructAsParamToFreeFunc>

    function.def @compute() -> !struct.type<@Main> {
      %self = struct.new : !struct.type<@Main>
      %z = felt.const 42
      %q = function.call @StructAsParamToFreeFunc::@compute(%z) : (!felt.type) -> !struct.type<@StructAsParamToFreeFunc>
      struct.writem %self[@f2] = %q : !struct.type<@Main>, !struct.type<@StructAsParamToFreeFunc>
      // expected-note@+1 {{used by this call}}
      function.call @temp(%q) : (!struct.type<@StructAsParamToFreeFunc>) -> ()
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %z = felt.const 42
      %q = struct.readm %self[@f2] : !struct.type<@Main>, !struct.type<@StructAsParamToFreeFunc>
      function.call @StructAsParamToFreeFunc::@constrain(%q, %z) : (!struct.type<@StructAsParamToFreeFunc>,!felt.type) -> ()
      function.return
    }
  }
}
// -----

module attributes {llzk.main = !struct.type<@Main>, veridise.lang = "llzk"} {
  struct.def @ComponentY<[@A, @B]> {
    function.def @compute() -> !struct.type<@ComponentY<[@A, @B]>> {
      %self = struct.new : !struct.type<@ComponentY<[@A, @B]>>
      function.return %self : !struct.type<@ComponentY<[@A, @B]>>
    }
    function.def @constrain(%self: !struct.type<@ComponentY<[@A, @B]>>) { function.return }
  }

  // expected-error@+1 {{Cannot inline structs with parameters.}}
  struct.def @ComponentX<[@C]> {
    struct.member @f2 : !struct.type<@ComponentY<[5, @C]>>

    function.def @compute() -> !struct.type<@ComponentX<[@C]>> {
      %self = struct.new : !struct.type<@ComponentX<[@C]>>
      %x = function.call @ComponentY::@compute() : () -> (!struct.type<@ComponentY<[5, @C]>>)
      struct.writem %self[@f2] = %x : !struct.type<@ComponentX<[@C]>>, !struct.type<@ComponentY<[5, @C]>>
      function.return %self : !struct.type<@ComponentX<[@C]>>
    }

    function.def @constrain(%self: !struct.type<@ComponentX<[@C]>>) {
      %b = struct.readm %self[@f2] : !struct.type<@ComponentX<[@C]>>, !struct.type<@ComponentY<[5, @C]>>
      function.call @ComponentY::@constrain(%b) : (!struct.type<@ComponentY<[5, @C]>>) -> ()
      function.return
    }
  }
}
