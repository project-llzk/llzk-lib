// REQUIRES: with-pcl
// RUN: llzk-opt -I %S -split-input-file -llzk-to-pcl -verify-diagnostics %s

// Expect the test to fail because the ComponentA2's constrain arg is not a felt
!F = !felt.type
module attributes {llzk.lang} {
  struct.def @ComponentA2 {
    function.def @compute(%p: !struct.type<@ComponentA1>) -> !struct.type<@ComponentA2> {
      %self = struct.new : !struct.type<@ComponentA2>
      %r = struct.readm %p[@f1] : !struct.type<@ComponentA1>, !array.type<4,3 x !F>
      function.return %self : !struct.type<@ComponentA2>
    }

    // expected-error@+1 {{Constrain function's args are expected to be felts. Found '!struct.type<@ComponentA1>'for arg #: 1}}
    function.def @constrain(%self: !struct.type<@ComponentA2>, %p: !struct.type<@ComponentA1>) {
      function.return
    }
  }

  struct.def @ComponentA1 {
    struct.member @f1 : !array.type<4,3 x !F> {llzk.pub}

    function.def @constrain(%self: !struct.type<@ComponentA1>) { function.return }
    function.def @compute() -> !struct.type<@ComponentA1> {
      %self = struct.new : !struct.type<@ComponentA1>
      function.return %self : !struct.type<@ComponentA1>
    }
  }
}

// -----

// Expect the test to fail because the ComponentA1 has a non-felt member
!F = !felt.type
module attributes {llzk.lang} {
  struct.def @ComponentA1 {
    // expected-error@+1 {{Member must be felt type. Found '!array.type<4,3 x !felt.type>' for member: f1}}
    struct.member @f1 : !array.type<4,3 x !F>

    function.def @constrain(%self: !struct.type<@ComponentA1>) { function.return }
    function.def @compute() -> !struct.type<@ComponentA1> {
      %self = struct.new : !struct.type<@ComponentA1>
      function.return %self : !struct.type<@ComponentA1>
    }
  }
}
