// RUN: llzk-opt -split-input-file -llzk-flatten %s | FileCheck --enable-var-scope %s

// TEST: partial instantiation of '@Zip' in first round of flattening pass and then the loop in '@Main'
//  unrolls allowing a subsequent round of the flattening pass loop to make complete instantiations.
#id = affine_map<(i)->(i)>
module attributes {llzk.lang} {
  struct.def @Pair<[@Fst, @Snd]> {
    function.def @compute() -> !struct.type<@Pair<[@Fst, @Snd]>> {
      %self = struct.new : !struct.type<@Pair<[@Fst, @Snd]>>
      function.return %self : !struct.type<@Pair<[@Fst, @Snd]>>
    }
    function.def @constrain(%arg0: !struct.type<@Pair<[@Fst, @Snd]>>) {
      function.return
    }
  }

  struct.def @Zip<[@N, @Lhs, @Rhs]> {
    struct.member @"$super" : !array.type<9 x !struct.type<@Pair<[!poly.tvar<@Lhs>, !poly.tvar<@Rhs>]>>> {llzk.pub}
    function.def @compute() -> !struct.type<@Zip<[@N, @Lhs, @Rhs]>> {
      %self = struct.new : !struct.type<@Zip<[@N, @Lhs, @Rhs]>>
      function.return %self : !struct.type<@Zip<[@N, @Lhs, @Rhs]>>
    }
    function.def @constrain(%arg0: !struct.type<@Zip<[@N, @Lhs, @Rhs]>>) {
      function.return
    }
  }

  struct.def @MakeGuess<[@PEGS]> {
    struct.member @"$temp" : !struct.type<@Zip<[@PEGS, !felt.type, !felt.type]>>

    function.def @compute() -> !struct.type<@MakeGuess<[@PEGS]>> {
      %self = struct.new : !struct.type<@MakeGuess<[@PEGS]>>
      function.return %self : !struct.type<@MakeGuess<[@PEGS]>>
    }

    function.def @constrain(%arg0: !struct.type<@MakeGuess<[@PEGS]>>) {
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %14 = struct.readm %arg0[@"$temp"] : !struct.type<@MakeGuess<[@PEGS]>>, !struct.type<@Zip<[@PEGS, !felt.type, !felt.type]>>
      %15 = struct.readm %14[@"$super"] : !struct.type<@Zip<[@PEGS, !felt.type, !felt.type]>>, !array.type<9 x !struct.type<@Pair<[!felt.type, !felt.type]>>>
      %17 = array.len %15, %c0 : !array.type<9 x !struct.type<@Pair<[!felt.type, !felt.type]>>>
      scf.for %arg5 = %c0 to %17 step %c1 {
        %34 = array.read %15[%arg5] : !array.type<9 x !struct.type<@Pair<[!felt.type, !felt.type]>>>, !struct.type<@Pair<[!felt.type, !felt.type]>>
      }
      function.return
    }
  }

  struct.def @Main<[]> {
    function.def @compute() -> !struct.type<@Main<[]>> {
      %self = struct.new : !struct.type<@Main<[]>>
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c5 = arith.constant 5 : index
      scf.for %i = %c0 to %c5 step %c1 {
        function.call @MakeGuess::@compute(){(%i)} : () -> !struct.type<@MakeGuess<[#id]>>
      }
      function.return %self : !struct.type<@Main<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Main<[]>>) {
      function.return
    }
  }
}

// CHECK-LABEL: struct.def @Pair_f_f {
// CHECK-NEXT:    function.def @compute() -> !struct.type<@Pair_f_f> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Pair_f_f>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@Pair_f_f>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@Pair_f_f>) attributes {function.allow_constraint} {
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @Zip_0_f_f {
// CHECK-NEXT:    struct.member @"$super" : !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@Zip_0_f_f> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Zip_0_f_f>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@Zip_0_f_f>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@Zip_0_f_f>) attributes {function.allow_constraint} {
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @Zip_1_f_f {
// CHECK-NEXT:    struct.member @"$super" : !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@Zip_1_f_f> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Zip_1_f_f>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@Zip_1_f_f>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@Zip_1_f_f>) attributes {function.allow_constraint} {
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @Zip_2_f_f {
// CHECK-NEXT:    struct.member @"$super" : !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@Zip_2_f_f> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Zip_2_f_f>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@Zip_2_f_f>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@Zip_2_f_f>) attributes {function.allow_constraint} {
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @Zip_3_f_f {
// CHECK-NEXT:    struct.member @"$super" : !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@Zip_3_f_f> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Zip_3_f_f>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@Zip_3_f_f>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@Zip_3_f_f>) attributes {function.allow_constraint} {
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @Zip_4_f_f {
// CHECK-NEXT:    struct.member @"$super" : !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@Zip_4_f_f> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Zip_4_f_f>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@Zip_4_f_f>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@Zip_4_f_f>) attributes {function.allow_constraint} {
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @MakeGuess_0 {
// CHECK-NEXT:    struct.member @"$temp" : !struct.type<@Zip_0_f_f>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@MakeGuess_0> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@MakeGuess_0>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@MakeGuess_0>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@MakeGuess_0>) attributes {function.allow_constraint} {
// CHECK-NEXT:      %[[V2:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:      %[[V3:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:      %[[V4:[0-9a-zA-Z_\.]+]] = struct.readm %[[V1]][@"$temp"] : <@MakeGuess_0>, !struct.type<@Zip_0_f_f>
// CHECK-NEXT:      %[[V5:[0-9a-zA-Z_\.]+]] = struct.readm %[[V4]][@"$super"] : <@Zip_0_f_f>, !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      %[[V6:[0-9a-zA-Z_\.]+]] = array.len %[[V5]], %[[V3]] : <9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      scf.for %[[V7:[0-9a-zA-Z_\.]+]] = %[[V3]] to %[[V6]] step %[[V2]] {
// CHECK-NEXT:        %[[V8:[0-9a-zA-Z_\.]+]] = array.read %[[V5]]{{\[}}%[[V7]]] : <9 x !struct.type<@Pair_f_f>>, !struct.type<@Pair_f_f>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @MakeGuess_1 {
// CHECK-NEXT:    struct.member @"$temp" : !struct.type<@Zip_1_f_f>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@MakeGuess_1> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@MakeGuess_1>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@MakeGuess_1>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@MakeGuess_1>) attributes {function.allow_constraint} {
// CHECK-NEXT:      %[[V2:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:      %[[V3:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:      %[[V4:[0-9a-zA-Z_\.]+]] = struct.readm %[[V1]][@"$temp"] : <@MakeGuess_1>, !struct.type<@Zip_1_f_f>
// CHECK-NEXT:      %[[V5:[0-9a-zA-Z_\.]+]] = struct.readm %[[V4]][@"$super"] : <@Zip_1_f_f>, !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      %[[V6:[0-9a-zA-Z_\.]+]] = array.len %[[V5]], %[[V3]] : <9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      scf.for %[[V7:[0-9a-zA-Z_\.]+]] = %[[V3]] to %[[V6]] step %[[V2]] {
// CHECK-NEXT:        %[[V8:[0-9a-zA-Z_\.]+]] = array.read %[[V5]]{{\[}}%[[V7]]] : <9 x !struct.type<@Pair_f_f>>, !struct.type<@Pair_f_f>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @MakeGuess_2 {
// CHECK-NEXT:    struct.member @"$temp" : !struct.type<@Zip_2_f_f>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@MakeGuess_2> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@MakeGuess_2>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@MakeGuess_2>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@MakeGuess_2>) attributes {function.allow_constraint} {
// CHECK-NEXT:      %[[V2:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:      %[[V3:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:      %[[V4:[0-9a-zA-Z_\.]+]] = struct.readm %[[V1]][@"$temp"] : <@MakeGuess_2>, !struct.type<@Zip_2_f_f>
// CHECK-NEXT:      %[[V5:[0-9a-zA-Z_\.]+]] = struct.readm %[[V4]][@"$super"] : <@Zip_2_f_f>, !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      %[[V6:[0-9a-zA-Z_\.]+]] = array.len %[[V5]], %[[V3]] : <9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      scf.for %[[V7:[0-9a-zA-Z_\.]+]] = %[[V3]] to %[[V6]] step %[[V2]] {
// CHECK-NEXT:        %[[V8:[0-9a-zA-Z_\.]+]] = array.read %[[V5]]{{\[}}%[[V7]]] : <9 x !struct.type<@Pair_f_f>>, !struct.type<@Pair_f_f>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @MakeGuess_3 {
// CHECK-NEXT:    struct.member @"$temp" : !struct.type<@Zip_3_f_f>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@MakeGuess_3> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@MakeGuess_3>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@MakeGuess_3>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@MakeGuess_3>) attributes {function.allow_constraint} {
// CHECK-NEXT:      %[[V2:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:      %[[V3:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:      %[[V4:[0-9a-zA-Z_\.]+]] = struct.readm %[[V1]][@"$temp"] : <@MakeGuess_3>, !struct.type<@Zip_3_f_f>
// CHECK-NEXT:      %[[V5:[0-9a-zA-Z_\.]+]] = struct.readm %[[V4]][@"$super"] : <@Zip_3_f_f>, !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      %[[V6:[0-9a-zA-Z_\.]+]] = array.len %[[V5]], %[[V3]] : <9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      scf.for %[[V7:[0-9a-zA-Z_\.]+]] = %[[V3]] to %[[V6]] step %[[V2]] {
// CHECK-NEXT:        %[[V8:[0-9a-zA-Z_\.]+]] = array.read %[[V5]]{{\[}}%[[V7]]] : <9 x !struct.type<@Pair_f_f>>, !struct.type<@Pair_f_f>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @MakeGuess_4 {
// CHECK-NEXT:    struct.member @"$temp" : !struct.type<@Zip_4_f_f>
// CHECK-NEXT:    function.def @compute() -> !struct.type<@MakeGuess_4> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@MakeGuess_4>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@MakeGuess_4>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V1:[0-9a-zA-Z_\.]+]]: !struct.type<@MakeGuess_4>) attributes {function.allow_constraint} {
// CHECK-NEXT:      %[[V2:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:      %[[V3:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:      %[[V4:[0-9a-zA-Z_\.]+]] = struct.readm %[[V1]][@"$temp"] : <@MakeGuess_4>, !struct.type<@Zip_4_f_f>
// CHECK-NEXT:      %[[V5:[0-9a-zA-Z_\.]+]] = struct.readm %[[V4]][@"$super"] : <@Zip_4_f_f>, !array.type<9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      %[[V6:[0-9a-zA-Z_\.]+]] = array.len %[[V5]], %[[V3]] : <9 x !struct.type<@Pair_f_f>>
// CHECK-NEXT:      scf.for %[[V7:[0-9a-zA-Z_\.]+]] = %[[V3]] to %[[V6]] step %[[V2]] {
// CHECK-NEXT:        %[[V8:[0-9a-zA-Z_\.]+]] = array.read %[[V5]]{{\[}}%[[V7]]] : <9 x !struct.type<@Pair_f_f>>, !struct.type<@Pair_f_f>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: struct.def @Main {
// CHECK-NEXT:    function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:      %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:      %[[V1:[0-9a-zA-Z_\.]+]] = function.call @MakeGuess_0::@compute() : () -> !struct.type<@MakeGuess_0>
// CHECK-NEXT:      %[[V2:[0-9a-zA-Z_\.]+]] = function.call @MakeGuess_1::@compute() : () -> !struct.type<@MakeGuess_1>
// CHECK-NEXT:      %[[V3:[0-9a-zA-Z_\.]+]] = function.call @MakeGuess_2::@compute() : () -> !struct.type<@MakeGuess_2>
// CHECK-NEXT:      %[[V4:[0-9a-zA-Z_\.]+]] = function.call @MakeGuess_3::@compute() : () -> !struct.type<@MakeGuess_3>
// CHECK-NEXT:      %[[V5:[0-9a-zA-Z_\.]+]] = function.call @MakeGuess_4::@compute() : () -> !struct.type<@MakeGuess_4>
// CHECK-NEXT:      function.return %[[V0]] : !struct.type<@Main>
// CHECK-NEXT:    }
// CHECK-NEXT:    function.def @constrain(%[[V6:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:      function.return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
