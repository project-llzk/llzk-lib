// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s

function.def @felt_to_index(%a: !felt.type) -> index {
  %b = cast.toindex %a
  function.return %b: index
}
//CHECK-LABEL: function.def @felt_to_index(
//CHECK-SAME:  %[[A0:[0-9a-zA-Z_\.]+]]: !felt.type) -> index {
//CHECK-NEXT:    %[[T0:[0-9a-zA-Z_\.]+]] = cast.toindex %[[A0]]
//CHECK-NEXT:    function.return %[[T0]] : index
//CHECK-NEXT:  }
// -----

function.def @i1_to_felt(%a: i1) -> !felt.type {
  %b = cast.tofelt %a : i1
  function.return %b: !felt.type
}
//CHECK-LABEL: function.def @i1_to_felt(
//CHECK-SAME:  %[[A0:[0-9a-zA-Z_\.]+]]: i1) -> !felt.type {
//CHECK-NEXT:    %[[T0:[0-9a-zA-Z_\.]+]] = cast.tofelt %[[A0]] : i1
//CHECK-NEXT:    function.return %[[T0]] : !felt.type
//CHECK-NEXT:  }
// -----

function.def @index_to_felt(%a: index) -> !felt.type {
  %b = cast.tofelt %a : index
  function.return %b: !felt.type
}
//CHECK-LABEL: function.def @index_to_felt(
//CHECK-SAME:  %[[A0:[0-9a-zA-Z_\.]+]]: index) -> !felt.type {
//CHECK-NEXT:    %[[T0:[0-9a-zA-Z_\.]+]] = cast.tofelt %[[A0]] : index
//CHECK-NEXT:    function.return %[[T0]] : !felt.type
//CHECK-NEXT:  }
// -----

function.def @lt_felt(%a: !felt.type, %b: !felt.type) -> !felt.type {
  %0 = bool.cmp lt(%a, %b)
  %1 = cast.tofelt %0 : i1
  function.return %1: !felt.type
}
//CHECK-LABEL: function.def @lt_felt(
//CHECK-SAME:  %[[A0:[0-9a-zA-Z_\.]+]]: !felt.type, %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type) -> !felt.type {
//CHECK-NEXT:    %[[T0:[0-9a-zA-Z_\.]+]] = bool.cmp lt(%[[A0]], %[[A1]])
//CHECK-NEXT:    %[[T1:[0-9a-zA-Z_\.]+]] = cast.tofelt %[[T0]] : i1
//CHECK-NEXT:    function.return %[[T1]] : !felt.type
//CHECK-NEXT:  }
// -----

module attributes {llzk.lang} {
  struct.def @C3 {
    struct.member @f1 : !felt.type {signal}
    function.def @compute() -> !struct.type<@C3> {
      %self = struct.new : !struct.type<@C3>
      function.return %self : !struct.type<@C3>
    }
    function.def @constrain(%self: !struct.type<@C3>) attributes { function.allow_non_native_field_ops} {
      %f = struct.readm %self[@f1] : !struct.type<@C3>, !felt.type
      %i = cast.toindex %f
      function.return
    }
  }
}
//CHECK-LABEL: struct.def @C3 {
//CHECK-NEXT:    struct.member @f1 : !felt.type {signal}
//CHECK-NEXT:    function.def @compute() -> !struct.type<@C3> attributes {function.allow_witness} {
//CHECK-NEXT:      %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@C3>
//CHECK-NEXT:      function.return %[[SELF]] : !struct.type<@C3>
//CHECK-NEXT:    }
//CHECK-NEXT:    function.def @constrain(
//CHECK-SAME:    %[[A0:[0-9a-zA-Z_\.]+]]: !struct.type<@C3>) attributes {function.allow_constraint, function.allow_non_native_field_ops} {
//CHECK-NEXT:      %[[T0:[0-9a-zA-Z_\.]+]] = struct.readm %[[A0]][@f1] : <@C3>, !felt.type
//CHECK-NEXT:      %[[T1:[0-9a-zA-Z_\.]+]] = cast.toindex %[[T0]]
//CHECK-NEXT:      function.return
//CHECK-NEXT:    }
//CHECK-NEXT:  }
