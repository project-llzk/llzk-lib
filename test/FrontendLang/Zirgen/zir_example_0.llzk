// RUN: llzk-opt %s | FileCheck --enable-var-scope %s

// Pre-defined structs to import in all files generated by zirgen frontend
module attributes {veridise.lang = "llzk"} {
  module @risc0 {
    struct.def @ValU32 {
      struct.member @low : !felt.type {llzk.pub}
      struct.member @high : !felt.type {llzk.pub}

      function.def @compute(%low: !felt.type, %high: !felt.type) -> !struct.type<@risc0::@ValU32> {
        %self = struct.new : !struct.type<@risc0::@ValU32>
        struct.writem %self[@low] = %low : !struct.type<@risc0::@ValU32>, !felt.type
        struct.writem %self[@high] = %high : !struct.type<@risc0::@ValU32>, !felt.type
        function.return %self : !struct.type<@risc0::@ValU32>
      }

      function.def @constrain(%self: !struct.type<@risc0::@ValU32>, %low: !felt.type, %high: !felt.type) {
        function.return
      }
    }

    struct.def @Reg {
      // ZIR frontend should mark function.return value with `pub`
      struct.member @reg : !felt.type {llzk.pub}

      function.def @compute(%v: !felt.type) -> !struct.type<@risc0::@Reg> {
        %self = struct.new : !struct.type<@risc0::@Reg>
        struct.writem %self[@reg] = %v : !struct.type<@risc0::@Reg>, !felt.type
        function.return %self : !struct.type<@risc0::@Reg>
      }

      function.def @constrain(%self: !struct.type<@risc0::@Reg>, %v: !felt.type) {
        %0 = struct.readm %self[@reg] : !struct.type<@risc0::@Reg>, !felt.type
        constrain.eq %v, %0 : !felt.type
        function.return
      }
    }

    struct.def @Div {
      struct.member @reciprocal : !felt.type
      // ZIR frontend should mark function.return value with `pub`
      struct.member @synthetic_return : !felt.type {llzk.pub}

      function.def @compute(%lhs: !felt.type, %rhs: !felt.type) -> !struct.type<@risc0::@Div> attributes {function.allow_non_native_field_ops} {
        %self = struct.new : !struct.type<@risc0::@Div>
        // res_inv := inv(rhs);
        %res_inv = felt.inv %rhs
        struct.writem %self[@reciprocal] = %res_inv : !struct.type<@risc0::@Div>, !felt.type
        // self.synthetic_return := res_inv * lhs;
        %res_mul = felt.mul %res_inv, %lhs
        struct.writem %self[@synthetic_return] = %res_mul : !struct.type<@risc0::@Div>, !felt.type
        //
        function.return %self : !struct.type<@risc0::@Div>
      }

      function.def @constrain(%self: !struct.type<@risc0::@Div>, %lhs: !felt.type, %rhs: !felt.type) {
        // emit self.reciprocal * rhs = 1;
        %res_inv = struct.readm %self[@reciprocal] : !struct.type<@risc0::@Div>, !felt.type
        %res_mul_1 = felt.mul %res_inv, %rhs
        %const_1 = felt.const 1
        constrain.eq %res_mul_1, %const_1 : !felt.type
        // emit self.synthetic_return = self.reciprocal * lhs;
        %res_self = struct.readm %self[@synthetic_return] : !struct.type<@risc0::@Div>, !felt.type
        %res_mul_2 = felt.mul %res_inv, %lhs
        constrain.eq %res_self, %res_mul_2 : !felt.type
        //
        function.return
      }
    }
  }
}

//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    module @risc0 {
//CHECK-NEXT:      struct.def @ValU32 {
//CHECK-NEXT:        struct.member @low : !felt.type
//CHECK-NEXT:        struct.member @high : !felt.type
//CHECK-NEXT:        function.def @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !felt.type, %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@risc0::@ValU32> attributes {function.allow_witness} {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@risc0::@ValU32>
//CHECK-NEXT:          struct.writem %[[SELF]][@low] = %[[A0]] : <@risc0::@ValU32>, !felt.type
//CHECK-NEXT:          struct.writem %[[SELF]][@high] = %[[A1]] : <@risc0::@ValU32>, !felt.type
//CHECK-NEXT:          function.return %[[SELF]] : !struct.type<@risc0::@ValU32>
//CHECK-NEXT:        }
//CHECK-NEXT:        function.def @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !struct.type<@risc0::@ValU32>,
//CHECK-SAME:        %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type, %[[A2:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
//CHECK-NEXT:          function.return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      struct.def @Reg {
//CHECK-NEXT:        struct.member @reg : !felt.type {llzk.pub}
//CHECK-NEXT:        function.def @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@risc0::@Reg> attributes {function.allow_witness} {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@risc0::@Reg>
//CHECK-NEXT:          struct.writem %[[SELF]][@reg] = %[[A0]] : <@risc0::@Reg>, !felt.type
//CHECK-NEXT:          function.return %[[SELF]] : !struct.type<@risc0::@Reg>
//CHECK-NEXT:        }
//CHECK-NEXT:        function.def @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !struct.type<@risc0::@Reg>, %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
//CHECK-NEXT:          %[[T0:[0-9a-zA-Z_\.]+]] = struct.readm %[[SELF]][@reg] : <@risc0::@Reg>, !felt.type
//CHECK-NEXT:          constrain.eq %[[A1]], %[[T0]] : !felt.type, !felt.type
//CHECK-NEXT:          function.return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      struct.def @Div {
//CHECK-NEXT:        struct.member @reciprocal : !felt.type
//CHECK-NEXT:        struct.member @synthetic_return : !felt.type {llzk.pub}
//CHECK-NEXT:        function.def @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !felt.type, %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@risc0::@Div> attributes {function.allow_non_native_field_ops, function.allow_witness} {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@risc0::@Div>
//CHECK-NEXT:          %[[T0:[0-9a-zA-Z_\.]+]] = felt.inv %[[A1]]
//CHECK-NEXT:          struct.writem %[[SELF]][@reciprocal] = %[[T0]] : <@risc0::@Div>, !felt.type
//CHECK-NEXT:          %[[T1:[0-9a-zA-Z_\.]+]] = felt.mul %[[T0]], %[[A0]]
//CHECK-NEXT:          struct.writem %[[SELF]][@synthetic_return] = %[[T1]] : <@risc0::@Div>, !felt.type
//CHECK-NEXT:          function.return %[[SELF]] : !struct.type<@risc0::@Div>
//CHECK-NEXT:        }
//CHECK-NEXT:        function.def @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !struct.type<@risc0::@Div>,
//CHECK-SAME:        %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type, %[[A2:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
//CHECK-NEXT:          %[[T0:[0-9a-zA-Z_\.]+]] = struct.readm %[[SELF]][@reciprocal] : <@risc0::@Div>, !felt.type
//CHECK-NEXT:          %[[T1:[0-9a-zA-Z_\.]+]] = felt.mul %[[T0]], %[[A2]]
//CHECK-NEXT:          %felt_const_1 = felt.const 1
//CHECK-NEXT:          constrain.eq %[[T1]], %felt_const_1 : !felt.type, !felt.type
//CHECK-NEXT:          %[[T2:[0-9a-zA-Z_\.]+]] = struct.readm %[[SELF]][@synthetic_return] : <@risc0::@Div>, !felt.type
//CHECK-NEXT:          %[[T3:[0-9a-zA-Z_\.]+]] = felt.mul %[[T0]], %[[A1]]
//CHECK-NEXT:          constrain.eq %[[T2]], %[[T3]] : !felt.type, !felt.type
//CHECK-NEXT:          function.return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
