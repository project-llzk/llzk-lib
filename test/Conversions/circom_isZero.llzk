module @Comparators attributes {llzk.lang = "llzk"} {
  struct.def @IsZero {
    struct.member @out: !felt.type {llzk.pub}
    struct.member @inv: !felt.type

    function.def @compute(%in: !felt.type) -> !struct.type<@IsZero> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@IsZero>
      %const_1 = felt.const 1
      %inv = felt.inv %in
      struct.writem %self[@inv] = %inv : !struct.type<@IsZero>, !felt.type
      %4 = felt.neg %in
      %5 = felt.mul %4, %inv
      %out = felt.add %5, %const_1
      struct.writem %self[@out] = %out : !struct.type<@IsZero>, !felt.type
      function.return %self: !struct.type<@IsZero>
    }

    function.def @constrain(%self: !struct.type<@IsZero>, %in: !felt.type) {
      %const_0 = felt.const 0
      %const_1 = felt.const 1
      %out = struct.readm %self[@out] : !struct.type<@IsZero>, !felt.type
      %inv = struct.readm %self[@inv] : !struct.type<@IsZero>, !felt.type
      %4 = felt.neg %in
      %5 = felt.mul %4, %inv
      %6 = felt.add %5, %const_1
      constrain.eq %out, %6 : !felt.type
      %7 = felt.mul %in, %out
      constrain.eq %7, %const_0 : !felt.type
      function.return
    }
  }
}
