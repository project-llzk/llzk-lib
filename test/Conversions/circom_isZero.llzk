// RUN: llzk-opt --convert-llzk-to-zklean %s 2>&1 | FileCheck --enable-var-scope %s

module @Comparators attributes {llzk.lang = "llzk"} {
  struct.def @IsZero {
    struct.member @out: !felt.type {llzk.pub}
    struct.member @inv: !felt.type

    function.def @compute(%in: !felt.type) -> !struct.type<@IsZero> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@IsZero>
      %const_1 = felt.const 1
      %inv = felt.inv %in
      struct.writem %self[@inv] = %inv : !struct.type<@IsZero>, !felt.type
      %4 = felt.neg %in
      %5 = felt.mul %4, %inv
      %out = felt.add %5, %const_1
      struct.writem %self[@out] = %out : !struct.type<@IsZero>, !felt.type
      function.return %self: !struct.type<@IsZero>
    }

    function.def @constrain(%self: !struct.type<@IsZero>, %in: !felt.type) {
      %const_0 = felt.const 0
      %const_1 = felt.const 1
      %out = struct.readm %self[@out] : !struct.type<@IsZero>, !felt.type
      %inv = struct.readm %self[@inv] : !struct.type<@IsZero>, !felt.type
      %4 = felt.neg %in
      %5 = felt.mul %4, %inv
      %6 = felt.add %5, %const_1
      constrain.eq %out, %6 : !felt.type
      %7 = felt.mul %in, %out
      constrain.eq %7, %const_0 : !felt.type
      function.return
    }
  }
}

// NOTE: Assertions have been autogenerated by scripts/generate-test-checks.py

// CHECK-LABEL: module @ZKLean attributes {llzk.lang = "llzk"} {
// CHECK-NEXT:    ZKLeanLean.structure @IsZero {
// CHECK-NEXT:      ZKLeanLean.member @out : !ZKExpr.zkexpr
// CHECK-NEXT:      ZKLeanLean.member @inv : !ZKExpr.zkexpr
// CHECK-NEXT:    }
// CHECK-NEXT:    func.func @IsZero__constrain(%[[VAL_0:[0-9a-zA-Z_\.]+]]: !ZKLeanLean.type<@IsZero>, %[[VAL_1:[0-9a-zA-Z_\.]+]]: !felt.type) {
// CHECK-NEXT:      %[[VAL_2:[0-9a-zA-Z_\.]+]] = felt.const  0
// CHECK-NEXT:      %[[VAL_3:[0-9a-zA-Z_\.]+]] = ZKExpr.Literal %[[VAL_2]]
// CHECK-NEXT:      %[[VAL_4:[0-9a-zA-Z_\.]+]] = felt.const  1
// CHECK-NEXT:      %[[VAL_5:[0-9a-zA-Z_\.]+]] = ZKExpr.Literal %[[VAL_4]]
// CHECK-NEXT:      %[[VAL_6:[0-9a-zA-Z_\.]+]] = ZKLeanLean.accessor %[[VAL_0]][@out] : <@IsZero>, !ZKExpr.zkexpr
// CHECK-NEXT:      %[[VAL_7:[0-9a-zA-Z_\.]+]] = ZKLeanLean.accessor %[[VAL_0]][@inv] : <@IsZero>, !ZKExpr.zkexpr
// CHECK-NEXT:      %[[VAL_8:[0-9a-zA-Z_\.]+]] = ZKExpr.Literal %[[VAL_1]]
// CHECK-NEXT:      %[[VAL_9:[0-9a-zA-Z_\.]+]] = ZKExpr.Neg %[[VAL_8]]
// CHECK-NEXT:      %[[VAL_10:[0-9a-zA-Z_\.]+]] = ZKExpr.Mul %[[VAL_9]] %[[VAL_7]]
// CHECK-NEXT:      %[[VAL_11:[0-9a-zA-Z_\.]+]] = ZKExpr.Add %[[VAL_10]] %[[VAL_5]]
// CHECK-NEXT:      %[[VAL_12:[0-9a-zA-Z_\.]+]] = ZKBuilder.ConstrainEq %[[VAL_6]] %[[VAL_11]]
// CHECK-NEXT:      %[[VAL_13:[0-9a-zA-Z_\.]+]] = ZKExpr.Mul %[[VAL_8]] %[[VAL_6]]
// CHECK-NEXT:      %[[VAL_14:[0-9a-zA-Z_\.]+]] = ZKBuilder.ConstrainEq %[[VAL_13]] %[[VAL_3]]
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }