// RUN: llzk-opt -split-input-file -llzk-print-interval-analysis %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "llzk"} {
  struct.def @ConstantConstraint {
    function.def @compute(%a: !felt.type) -> !struct.type<@ConstantConstraint> {
      %self = struct.new : !struct.type<@ConstantConstraint>
      function.return %self : !struct.type<@ConstantConstraint>
    }

    function.def @constrain(%self: !struct.type<@ConstantConstraint>, %const: !felt.type) {
      %a = felt.const 1
      %b = felt.const 2
      %c = felt.add %a, %b
      constrain.eq %const, %c : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @ConstantConstraint StructIntervals {
// CHECK-NEXT:     %arg1 in Degenerate(3)
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @CmpConstraint {
    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@CmpConstraint> {
      %self = struct.new : !struct.type<@CmpConstraint>
      function.return %self : !struct.type<@CmpConstraint>
    }

    function.def @constrain(%self: !struct.type<@CmpConstraint>, %a: !felt.type, %b: !felt.type) {
      %x = felt.const 1
      %y = felt.const 2
      %cmpA = bool.cmp gt(%a, %x)
      bool.assert %cmpA
      %cmpB = bool.cmp le(%b, %y)
      bool.assert %cmpB
      function.return
    }
  }
}

// CHECK-LABEL: @CmpConstraint StructIntervals {
// CHECK-NEXT:     %arg1 in TypeC:[ 2, 21888242871839275222246405745257275088696311157297823662689037894645226208582 ]
// CHECK-NEXT:     %arg2 in TypeA:[ 0, 2 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @FieldRangeConstraint {

    struct.field @foo : !felt.type
    struct.field @bar : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@FieldRangeConstraint> {
      %self = struct.new : !struct.type<@FieldRangeConstraint>
      function.return %self : !struct.type<@FieldRangeConstraint>
    }

    function.def @constrain(%self: !struct.type<@FieldRangeConstraint>, %a: !felt.type, %b: !felt.type) {
      %x = felt.const 1
      %y = felt.const 2
      %cmpA = bool.cmp gt(%a, %x)
      bool.assert %cmpA
      %cmpB = bool.cmp le(%b, %y)
      bool.assert %cmpB
      %foo = struct.readf %self[@foo] : !struct.type<@FieldRangeConstraint>, !felt.type
      constrain.eq %foo, %x : !felt.type
      %bar = struct.readf %self[@bar] : !struct.type<@FieldRangeConstraint>, !felt.type
      constrain.eq %bar, %b : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @FieldRangeConstraint StructIntervals {
// CHECK-NEXT:     %arg0[@foo] in Degenerate(1)
// CHECK-NEXT:     %arg0[@bar] in TypeA:[ 0, 2 ]
// CHECK-NEXT:     %arg1 in TypeC:[ 2, 21888242871839275222246405745257275088696311157297823662689037894645226208582 ]
// CHECK-NEXT:     %arg2 in TypeA:[ 0, 2 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @ArrayConstraint {

    struct.field @arr : !array.type<3 x !felt.type>

    function.def @compute() -> !struct.type<@ArrayConstraint> {
      %self = struct.new : !struct.type<@ArrayConstraint>
      function.return %self : !struct.type<@ArrayConstraint>
    }

    function.def @constrain(%self: !struct.type<@ArrayConstraint>) {
      %5 = felt.const 5
      %7 = felt.const 7
      %11 = felt.const 11
      %arr = struct.readf %self[@arr] : !struct.type<@ArrayConstraint>, !array.type<3 x !felt.type>
      %i0 = arith.constant 0 : index
      %i1 = arith.constant 1 : index
      %i2 = arith.constant 2 : index
      %a = array.read %arr[%i0] : !array.type<3 x !felt.type>, !felt.type
      %b = array.read %arr[%i1] : !array.type<3 x !felt.type>, !felt.type
      %c = array.read %arr[%i2] : !array.type<3 x !felt.type>, !felt.type
      %cmp1 = bool.cmp ge(%a, %5)
      bool.assert %cmp1
      %cmp2 = bool.cmp le(%a, %7)
      bool.assert %cmp2
      %cmp3 = bool.cmp ge(%b, %7)
      bool.assert %cmp3
      %cmp4 = bool.cmp le(%b, %11)
      bool.assert %cmp4

      constrain.eq %c, %a : !felt.type

      function.return
    }
  }
}

// CHECK-LABEL: @ArrayConstraint StructIntervals {
// CHECK-NEXT:     %arg0[@arr][0] in TypeA:[ 5, 7 ]
// CHECK-NEXT:     %arg0[@arr][1] in TypeA:[ 7, 11 ]
// CHECK-NEXT:     %arg0[@arr][2] in TypeA:[ 5, 7 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @Div<[]> {
    struct.field @"$super" : !felt.type
    struct.field @reciprocal : !felt.type
    function.def @compute(%arg0: !felt.type, %arg1: !felt.type) -> !struct.type<@Div<[]>> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : <@Div<[]>>
      %0 = felt.inv %arg1 : !felt.type
      struct.writef %self[@reciprocal] = %0 : <@Div<[]>>, !felt.type
      %1 = struct.readf %self[@reciprocal] : <@Div<[]>>, !felt.type
      %2 = felt.mul %1, %arg1 : !felt.type, !felt.type
      %felt_const_1 = felt.const  1
      %3 = felt.mul %1, %arg0 : !felt.type, !felt.type
      struct.writef %self[@"$super"] = %3 : <@Div<[]>>, !felt.type
      function.return %self : !struct.type<@Div<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@Div<[]>>, %arg1: !felt.type, %arg2: !felt.type) {
      %0 = struct.readf %arg0[@reciprocal] : <@Div<[]>>, !felt.type
      %1 = felt.mul %0, %arg2 : !felt.type, !felt.type
      %felt_const_1 = felt.const  1
      // Since reciprocal * arg2 === 1, reciprocal nor arg2 can be 0
      constrain.eq %1, %felt_const_1 : !felt.type, !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @Div StructIntervals {
// CHECK-NEXT:     %arg0[@$super] in Entire
// CHECK-NEXT:     %arg0[@reciprocal] in TypeC:[ 1, 21888242871839275222246405745257275088696311157297823662689037894645226208582 ]
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %arg2 in TypeC:[ 1, 21888242871839275222246405745257275088696311157297823662689037894645226208582 ]
// CHECK-NEXT: }

// -----

// Ensure we still report all structs if they're all at an unknown location
#loc = loc(unknown)
module attributes {veridise.lang = "llzk"} {
  // A correctly constrained byte decomposition checker for a 16 bit val.
  struct.def @ByteDecompCorrect {
    struct.field @b1 : !felt.type
    struct.field @b0 : !felt.type

    function.def @compute(%u16 : !felt.type) -> !struct.type<@ByteDecompCorrect> {
      %self = struct.new : !struct.type<@ByteDecompCorrect>
      function.return %self : !struct.type<@ByteDecompCorrect>
    }

    function.def @constrain(%self : !struct.type<@ByteDecompCorrect>, %u16 : !felt.type) {
      %b0 = struct.readf %self[@b0] : !struct.type<@ByteDecompCorrect>, !felt.type
      %b1 = struct.readf %self[@b1] : !struct.type<@ByteDecompCorrect>, !felt.type
      %256 = felt.const 256
      %b0_is_byte = bool.cmp lt(%b0, %256)
      %b1_is_byte = bool.cmp lt(%b1, %256)
      bool.assert %b0_is_byte
      bool.assert %b1_is_byte
      %b1_mul = felt.mul %b1, %256
      %reconstructed = felt.add %b1_mul, %b0
      constrain.eq %reconstructed, %u16 : !felt.type
      function.return
    }
  } loc(#loc)

  // An incorrectly constrained byte decomposition checker for a 16 bit val.
  struct.def @ByteDecompIncorrect {
    struct.field @b1 : !felt.type
    struct.field @b0 : !felt.type

    function.def @compute(%u16 : !felt.type) -> !struct.type<@ByteDecompIncorrect> {
      %self = struct.new : !struct.type<@ByteDecompIncorrect>
      function.return %self : !struct.type<@ByteDecompIncorrect>
    }

    function.def @constrain(%self : !struct.type<@ByteDecompIncorrect>, %u16 : !felt.type) {
      %b0 = struct.readf %self[@b0] : !struct.type<@ByteDecompIncorrect>, !felt.type
      %b1 = struct.readf %self[@b1] : !struct.type<@ByteDecompIncorrect>, !felt.type
      %256 = felt.const 256
      %b1_mul = felt.mul %b1, %256
      %reconstructed = felt.add %b1_mul, %b0
      // b0 and b1 are not constrained to be a byte, so these values could be anything
      constrain.eq %reconstructed, %u16 : !felt.type
      function.return
    }
  } loc(#loc)

  // Another improperly constrained byte decomposition checker for a 16 bit val.
  struct.def @ByteDecompPartial {
    struct.field @b1 : !felt.type
    struct.field @b0 : !felt.type

    function.def @compute(%u16 : !felt.type) -> !struct.type<@ByteDecompPartial> {
      %self = struct.new : !struct.type<@ByteDecompPartial>
      function.return %self : !struct.type<@ByteDecompPartial>
    }

    function.def @constrain(%self : !struct.type<@ByteDecompPartial>, %u16 : !felt.type) {
      %b0 = struct.readf %self[@b0] : !struct.type<@ByteDecompPartial>, !felt.type
      %b1 = struct.readf %self[@b1] : !struct.type<@ByteDecompPartial>, !felt.type
      %256 = felt.const 256
      %u16upper = felt.mul %256, %256
      %is_u16 = bool.cmp lt(%u16, %u16upper)
      bool.assert %is_u16
      %b1_mul = felt.mul %b1, %256
      %reconstructed = felt.add %b1_mul, %b0
      // u16 is constrained to be 16 bites, but b0 and b1 aren't guaranteed to
      // by bytes, so they could be any value (even above 16-bits, if b0 and b1)
      // are carefully selected to overflow into 16 bits).
      constrain.eq %reconstructed, %u16 : !felt.type
      function.return
    }
  } loc(#loc)
}

// CHECK-LABEL: @ByteDecompCorrect StructIntervals {
// CHECK-NEXT:     %arg0[@b1] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %arg0[@b0] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %arg1 in TypeA:[ 0, 65535 ]
// CHECK-NEXT: }
// CHECK-NEXT: @ByteDecompIncorrect StructIntervals {
// CHECK-NEXT:     %arg0[@b1] in Entire
// CHECK-NEXT:     %arg0[@b0] in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT: }
// CHECK-NEXT: @ByteDecompPartial StructIntervals {
// CHECK-NEXT:     %arg0[@b1] in Entire
// CHECK-NEXT:     %arg0[@b0] in Entire
// CHECK-NEXT:     %arg1 in TypeA:[ 0, 65535 ]
// CHECK-NEXT: }

// -----

// Ensure constraints on Signals or on the Signal's internal reg propagate.
!Signal = !struct.type<@Signal>
module attributes {veridise.lang = "llzk"} {
  // pre-defined
  struct.def @Signal {
    struct.field @reg : !felt.type {llzk.pub}

    function.def @compute(%v: !felt.type) -> !struct.type<@Signal> {
      %self = struct.new : !struct.type<@Signal>
      struct.writef %self[@reg] = %v : !struct.type<@Signal>, !felt.type
      function.return %self : !struct.type<@Signal>
    }

    function.def @constrain(%self: !struct.type<@Signal>, %v: !felt.type) {
      function.return
    }
  }

  struct.def @Component00 {
    struct.field @f : !Signal

    function.def @compute(%0: !Signal) -> !struct.type<@Component00> {
      %self = struct.new : !struct.type<@Component00>
      struct.writef %self[@f] = %0 : !struct.type<@Component00>, !Signal
      function.return %self : !struct.type<@Component00>
    }
    function.def @constrain(%self: !struct.type<@Component00>, %0: !Signal) {
      %b = struct.readf %self[@f] : !struct.type<@Component00>, !Signal
      constrain.eq %b, %0 : !Signal
      %reg = struct.readf %0[@reg] : !Signal, !felt.type
      %c0 = felt.const 0
      constrain.eq %reg, %c0 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @Component00 StructIntervals {
// CHECK-NEXT:     %arg0[@f] in Degenerate(0)
// CHECK-NEXT:     %arg1 in Degenerate(0)
// CHECK-NEXT: }

// -----

// Bit pattern s * (s - 1) = 0
module attributes {veridise.lang = "llzk"} {
  struct.def @BitConstraint {
    struct.field @bit : !felt.type

    function.def @compute() -> !struct.type<@BitConstraint> {
      %self = struct.new : !struct.type<@BitConstraint>
      function.return %self : !struct.type<@BitConstraint>
    }
    function.def @constrain(%self: !struct.type<@BitConstraint>) {
      %c0 = felt.const 0
      %c1 = felt.const 1
      %bit = struct.readf %self[@bit] : !struct.type<@BitConstraint>, !felt.type
      %bitSub1 = felt.sub %bit, %c1
      %decomp = felt.mul %bit, %bitSub1
      constrain.eq %decomp, %c0 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @BitConstraint StructIntervals {
// CHECK-NEXT:    %arg0[@bit] in TypeA:[ 0, 1 ]
// CHECK-NEXT: }

// -----

// Twit pattern s * (s - 1) * (s - 2) * (s - 3) = 0
module attributes {veridise.lang = "llzk"} {
  struct.def @BitConstraint {
    struct.field @bit : !felt.type

    function.def @compute() -> !struct.type<@BitConstraint> {
      %self = struct.new : !struct.type<@BitConstraint>
      function.return %self : !struct.type<@BitConstraint>
    }
    function.def @constrain(%self: !struct.type<@BitConstraint>) {
      %c0 = felt.const 0
      %c1 = felt.const 1
      %c2 = felt.const 2
      %c3 = felt.const 3
      %bit = struct.readf %self[@bit] : !struct.type<@BitConstraint>, !felt.type
      %bitSub1 = felt.sub %bit, %c1
      %bitSub2 = felt.sub %bit, %c2
      %bitSub3 = felt.sub %bit, %c3
      %decomp1 = felt.mul %bit, %bitSub1
      %decomp2 = felt.mul %decomp1, %bitSub2
      %decomp3 = felt.mul %decomp2, %bitSub3
      constrain.eq %decomp3, %c0 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @BitConstraint StructIntervals {
// CHECK-NEXT:    %arg0[@bit] in TypeA:[ 0, 3 ]
// CHECK-NEXT: }

// -----

// Sparse pattern s * (s - 3) = 0
module attributes {veridise.lang = "llzk"} {
  struct.def @BitConstraint {
    struct.field @bit : !felt.type

    function.def @compute() -> !struct.type<@BitConstraint> {
      %self = struct.new : !struct.type<@BitConstraint>
      function.return %self : !struct.type<@BitConstraint>
    }
    function.def @constrain(%self: !struct.type<@BitConstraint>) {
      %c0 = felt.const 0
      %c3 = felt.const 3
      %bit = struct.readf %self[@bit] : !struct.type<@BitConstraint>, !felt.type
      %bitSub3 = felt.sub %bit, %c3
      %decomp = felt.mul %bit, %bitSub3
      constrain.eq %decomp, %c0 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @BitConstraint StructIntervals {
// CHECK-NEXT:    %arg0[@bit] in TypeA:[ 0, 3 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @CheckBit {
    function.def @compute(%maybeBit: !felt.type) -> !struct.type<@CheckBit> {
      %self = struct.new : <@CheckBit>
      function.return %self : !struct.type<@CheckBit>
    }

    function.def @constrain(%self : !struct.type<@CheckBit>, %maybeBit: !felt.type) {
      %felt_const_1 = felt.const 1
      %felt_const_2 = felt.const 2
      %lt2 = bool.cmp lt(%maybeBit, %felt_const_2)
      %lt2_felt = cast.tofelt %lt2 : i1
      // Constrain that %maybeBit < 2, meaning %maybeBit is in [0, 1]
      constrain.eq %lt2_felt, %felt_const_1 : !felt.type
      function.return
    }
  }

  struct.def @CheckBitInv {
    function.def @compute(%maybeBit: !felt.type) -> !struct.type<@CheckBitInv> {
      %self = struct.new : <@CheckBitInv>
      function.return %self : !struct.type<@CheckBitInv>
    }

    function.def @constrain(%self : !struct.type<@CheckBitInv>, %maybeBit: !felt.type) {
      %felt_const_0 = felt.const 0
      %felt_const_2 = felt.const 2
      %ge2 = bool.cmp ge(%maybeBit, %felt_const_2)
      %ge2_felt = cast.tofelt %ge2 : i1
      // Constrain that is not %maybeBit >= 2, meaning %maybeBit is in [0, 1]
      constrain.eq %ge2_felt, %felt_const_0 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @CheckBit StructIntervals {
// CHECK:     %arg1 in TypeA:[ 0, 1 ]
// CHECK: }
// CHECK-LABEL: @CheckBitInv StructIntervals {
// CHECK:     %arg1 in TypeA:[ 0, 1 ]
// CHECK: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @IntTest<[]> {
    struct.field @x : !felt.type {llzk.pub}
    struct.field @y : !felt.type {llzk.pub}
    function.def @compute() -> !struct.type<@IntTest<[]>> attributes {function.allow_witness} {
      %self = struct.new : <@IntTest<[]>>
      function.return %self : !struct.type<@IntTest<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@IntTest<[]>>) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@x] : <@IntTest<[]>>, !felt.type
      %1 = struct.readf %arg0[@y] : <@IntTest<[]>>, !felt.type
      %felt_const_65536 = felt.const  65536
      %felt_const_1 = felt.const  1
      %felt_const_256 = felt.const  256
      %felt_const_512 = felt.const  512
      %2 = felt.add %0, %1 : !felt.type, !felt.type
      %3 = bool.cmp lt(%2, %felt_const_65536)
      %4 = bool.cmp lt(%0, %felt_const_512)
      %5 = cast.tofelt %3 : i1
      %6 = cast.tofelt %4 : i1
      constrain.eq %5, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %6, %felt_const_1 : !felt.type, !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @IntTest StructIntervals {
// CHECK-NEXT:     %arg0[@x] in TypeA:[ 0, 511 ]
// CHECK-NEXT:     %arg0[@y] in TypeF:[ 21888242871839275222246405745257275088696311157297823662689037894645226208072, 65535 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @IntTest<[]> {
    struct.field @x : !felt.type {llzk.pub}
    struct.field @y : !felt.type {llzk.pub}
    struct.field @z : !felt.type {llzk.pub}
    function.def @compute() -> !struct.type<@IntTest<[]>> attributes {function.allow_witness} {
      %self = struct.new : <@IntTest<[]>>
      function.return %self : !struct.type<@IntTest<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@IntTest<[]>>) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@x] : <@IntTest<[]>>, !felt.type
      %1 = struct.readf %arg0[@y] : <@IntTest<[]>>, !felt.type
      %2 = struct.readf %arg0[@z] : <@IntTest<[]>>, !felt.type
      %felt_const_65536 = felt.const  65536
      %felt_const_1 = felt.const  1
      %felt_const_256 = felt.const  256
      %felt_const_512 = felt.const  512
      %3 = felt.mul %0, %1 : !felt.type, !felt.type
      %4 = bool.cmp lt(%3, %felt_const_65536)
      %5 = bool.cmp ge(%1, %felt_const_256)
      %6 = bool.cmp lt(%1, %felt_const_512)
      %7 = bool.cmp lt(%0, %felt_const_512)
      %8 = cast.tofelt %4 : i1
      %9 = cast.tofelt %5 : i1
      %10 = cast.tofelt %7 : i1
      %11 = cast.tofelt %6 : i1
      constrain.eq %8, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %9, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %10, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %11, %felt_const_1 : !felt.type, !felt.type
      %12 = felt.mul %1, %felt_const_256 : !felt.type, !felt.type
      %13 = felt.add %12, %0 : !felt.type, !felt.type
      constrain.eq %2, %13 : !felt.type, !felt.type
      function.return
    }
  }
}

// TODO: Refine multiplication range
// CHECK-LABEL: @IntTest StructIntervals {
// CHECK-NEXT:     %arg0[@x] in TypeA:[ 0, 511 ]
// CHECK-NEXT:     %arg0[@y] in TypeA:[ 256, 511 ]
// CHECK-NEXT:     %arg0[@z] in TypeA:[ 65536, 131327 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @IntTest<[]> {
    struct.field @x: !felt.type {llzk.pub}
    struct.field @y : !felt.type {llzk.pub}

    function.def @compute() -> !struct.type<@IntTest<[]>> attributes {function.allow_witness} {
      %self = struct.new : <@IntTest<[]>>
      function.return %self : !struct.type<@IntTest<[]>>
    }

    function.def @constrain(%self: !struct.type<@IntTest<[]>>) attributes {function.allow_constraint} {
      %x = struct.readf %self[@x] : <@IntTest<[]>>, !felt.type
      %y = struct.readf %self[@y] : <@IntTest<[]>>, !felt.type
      %65536 = felt.const 65536

      %one = felt.const 1
      %256 = felt.const 256
      %512 = felt.const 512
      %m = felt.add %x, %y : !felt.type, !felt.type
      // These two conditions are contradictory
      %0 = bool.cmp lt(%m, %65536)
      %1 = bool.cmp ge(%m, %65536)
      %2 = bool.cmp lt(%x, %512)
      %bool0 = cast.tofelt %0 : i1
      %bool1 = cast.tofelt %1 : i1
      %bool2 = cast.tofelt %2 : i1
      constrain.eq %bool0, %one : !felt.type, !felt.type
      constrain.eq %bool1, %one : !felt.type, !felt.type
      constrain.eq %bool2, %one : !felt.type, !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @IntTest StructIntervals {
// CHECK-NEXT:     %arg0[@x] in TypeA:[ 0, 511 ]
// CHECK-NEXT:     %arg0[@y] in Entire
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @IntTest<[]> {
    struct.field @x: !felt.type {llzk.pub}
    struct.field @y : !felt.type {llzk.pub}

    function.def @compute() -> !struct.type<@IntTest<[]>> attributes {function.allow_witness} {
      %self = struct.new : <@IntTest<[]>>
      function.return %self : !struct.type<@IntTest<[]>>
    }

    function.def @constrain(%self: !struct.type<@IntTest<[]>>) attributes {function.allow_constraint} {
      %x = struct.readf %self[@x] : <@IntTest<[]>>, !felt.type
      %y = struct.readf %self[@y] : <@IntTest<[]>>, !felt.type
      %65536 = felt.const 65536
      %32768 = felt.const 32768

      %one = felt.const 1
      %256 = felt.const 256
      %512 = felt.const 512
      %m = felt.add %x, %y : !felt.type, !felt.type
      %0 = bool.cmp lt(%m, %65536)
      %1 = bool.cmp ge(%m, %32768)
      %2 = bool.cmp lt(%x, %512)
      %bool0 = cast.tofelt %0 : i1
      %bool1 = cast.tofelt %1 : i1
      %bool2 = cast.tofelt %2 : i1
      constrain.eq %bool0, %one : !felt.type, !felt.type
      constrain.eq %bool1, %one : !felt.type, !felt.type
      constrain.eq %bool2, %one : !felt.type, !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @IntTest StructIntervals {
// CHECK-NEXT:     %arg0[@x] in TypeA:[ 0, 511 ]
// CHECK-NEXT:     %arg0[@y] in TypeA:[ 32257, 65535 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @SubTest<[]> {
    struct.field @x : !felt.type {llzk.pub}
    struct.field @y : !felt.type {llzk.pub}
    struct.field @z : !felt.type {llzk.pub}
    function.def @compute() -> !struct.type<@SubTest<[]>> attributes {function.allow_witness} {
      %self = struct.new : <@SubTest<[]>>
      function.return %self : !struct.type<@SubTest<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@SubTest<[]>>) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@x] : <@SubTest<[]>>, !felt.type
      %1 = struct.readf %arg0[@y] : <@SubTest<[]>>, !felt.type
      // Note: y is read twice
      %2 = struct.readf %arg0[@y] : <@SubTest<[]>>, !felt.type
      %felt_const_1 = felt.const  1
      %felt_const_256 = felt.const  256
      %3 = felt.sub %0, %1 : !felt.type, !felt.type
      %4 = bool.cmp lt(%0, %felt_const_256)
      %5 = bool.cmp lt(%1, %felt_const_256)
      %6 = cast.tofelt %4 : i1
      %7 = cast.tofelt %5 : i1
      constrain.eq %6, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %7, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %2, %3 : !felt.type, !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @SubTest StructIntervals {
// CHECK-NEXT:     %arg0[@x] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %arg0[@y] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %arg0[@z] in Entire
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @SubTest<[]> {
    struct.field @x : !felt.type {llzk.pub}
    struct.field @y : !felt.type {llzk.pub}
    struct.field @z : !felt.type {llzk.pub}
    function.def @compute() -> !struct.type<@SubTest<[]>> attributes {function.allow_witness} {
      %self = struct.new : <@SubTest<[]>>
      function.return %self : !struct.type<@SubTest<[]>>
    }
    function.def @constrain(%arg0: !struct.type<@SubTest<[]>>) attributes {function.allow_constraint} {
      %0 = struct.readf %arg0[@x] : <@SubTest<[]>>, !felt.type
      %1 = struct.readf %arg0[@y] : <@SubTest<[]>>, !felt.type
      %2 = struct.readf %arg0[@z] : <@SubTest<[]>>, !felt.type
      %felt_const_1 = felt.const  1
      %felt_const_256 = felt.const  256
      %3 = felt.sub %0, %1 : !felt.type, !felt.type
      %4 = bool.cmp lt(%0, %felt_const_256)
      %5 = bool.cmp lt(%1, %felt_const_256)
      %6 = cast.tofelt %4 : i1
      %7 = cast.tofelt %5 : i1
      constrain.eq %6, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %7, %felt_const_1 : !felt.type, !felt.type
      constrain.eq %2, %3 : !felt.type, !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @SubTest StructIntervals {
// CHECK-NEXT:     %arg0[@x] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %arg0[@y] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %arg0[@z] in TypeF:[ 21888242871839275222246405745257275088696311157297823662689037894645226208328, 255 ]
// CHECK-NEXT: }

// -----

// COM: Regression test to avoid assertion failure on empty modules
module attributes {veridise.lang = "llzk"} { }
