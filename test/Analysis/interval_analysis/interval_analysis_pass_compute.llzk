// RUN: llzk-opt -I %input_dir -llzk-inline-includes -split-input-file -llzk-print-interval-analysis="field=babybear print-compute-intervals propagate-input-constraints" %s 2>&1 | FileCheck %s

module attributes {llzk.lang} {
  struct.def @BoolAnd {
    struct.member @case0 : i1
    struct.member @case1 : i1
    struct.member @case2 : i1
    struct.member @case3 : i1
    struct.member @case4 : i1
    struct.member @case5 : i1
    struct.member @case6 : i1
    struct.member @case7 : i1
    struct.member @case8 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolAnd> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@BoolAnd>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.and %true, %true
      %case1 = bool.and %true, %false
      %case2 = bool.and %false, %true
      %case3 = bool.and %false, %false
      %case4 = bool.and %any, %any
      %case5 = bool.and %any, %true
      %case6 = bool.and %true, %any
      %case7 = bool.and %any, %false
      %case8 = bool.and %false, %any

      struct.writem %self[@case0] = %case0 : <@BoolAnd>, i1
      struct.writem %self[@case1] = %case1 : <@BoolAnd>, i1
      struct.writem %self[@case2] = %case2 : <@BoolAnd>, i1
      struct.writem %self[@case3] = %case3 : <@BoolAnd>, i1
      struct.writem %self[@case4] = %case4 : <@BoolAnd>, i1
      struct.writem %self[@case5] = %case5 : <@BoolAnd>, i1
      struct.writem %self[@case6] = %case6 : <@BoolAnd>, i1
      struct.writem %self[@case7] = %case7 : <@BoolAnd>, i1
      struct.writem %self[@case8] = %case8 : <@BoolAnd>, i1

      function.return %self : !struct.type<@BoolAnd>
    }

    function.def @constrain(%self: !struct.type<@BoolAnd>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @BoolAnd StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(1)
// CHECK-NEXT:     %self[@case1] in Degenerate(0)
// CHECK-NEXT:     %self[@case2] in Degenerate(0)
// CHECK-NEXT:     %self[@case3] in Degenerate(0)
// CHECK-NEXT:     %self[@case4] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case5] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case6] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case7] in Degenerate(0)
// CHECK-NEXT:     %self[@case8] in Degenerate(0)
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  struct.def @BoolOr {
    struct.member @case0 : i1
    struct.member @case1 : i1
    struct.member @case2 : i1
    struct.member @case3 : i1
    struct.member @case4 : i1
    struct.member @case5 : i1
    struct.member @case6 : i1
    struct.member @case7 : i1
    struct.member @case8 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolOr> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@BoolOr>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.or %true, %true
      %case1 = bool.or %true, %false
      %case2 = bool.or %false, %true
      %case3 = bool.or %false, %false
      %case4 = bool.or %any, %any
      %case5 = bool.or %any, %true
      %case6 = bool.or %true, %any
      %case7 = bool.or %any, %false
      %case8 = bool.or %false, %any

      struct.writem %self[@case0] = %case0 : <@BoolOr>, i1
      struct.writem %self[@case1] = %case1 : <@BoolOr>, i1
      struct.writem %self[@case2] = %case2 : <@BoolOr>, i1
      struct.writem %self[@case3] = %case3 : <@BoolOr>, i1
      struct.writem %self[@case4] = %case4 : <@BoolOr>, i1
      struct.writem %self[@case5] = %case5 : <@BoolOr>, i1
      struct.writem %self[@case6] = %case6 : <@BoolOr>, i1
      struct.writem %self[@case7] = %case7 : <@BoolOr>, i1
      struct.writem %self[@case8] = %case8 : <@BoolOr>, i1

      function.return %self : !struct.type<@BoolOr>
    }

    function.def @constrain(%self: !struct.type<@BoolOr>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @BoolOr StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(1)
// CHECK-NEXT:     %self[@case1] in Degenerate(1)
// CHECK-NEXT:     %self[@case2] in Degenerate(1)
// CHECK-NEXT:     %self[@case3] in Degenerate(0)
// CHECK-NEXT:     %self[@case4] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case5] in Degenerate(1)
// CHECK-NEXT:     %self[@case6] in Degenerate(1)
// CHECK-NEXT:     %self[@case7] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case8] in TypeA:[ 0, 1 ]
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  struct.def @BoolXor {
    struct.member @case0 : i1
    struct.member @case1 : i1
    struct.member @case2 : i1
    struct.member @case3 : i1
    struct.member @case4 : i1
    struct.member @case5 : i1
    struct.member @case6 : i1
    struct.member @case7 : i1
    struct.member @case8 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolXor> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@BoolXor>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.xor %true, %true
      %case1 = bool.xor %true, %false
      %case2 = bool.xor %false, %true
      %case3 = bool.xor %false, %false
      %case4 = bool.xor %any, %any
      %case5 = bool.xor %any, %true
      %case6 = bool.xor %true, %any
      %case7 = bool.xor %any, %false
      %case8 = bool.xor %false, %any

      struct.writem %self[@case0] = %case0 : <@BoolXor>, i1
      struct.writem %self[@case1] = %case1 : <@BoolXor>, i1
      struct.writem %self[@case2] = %case2 : <@BoolXor>, i1
      struct.writem %self[@case3] = %case3 : <@BoolXor>, i1
      struct.writem %self[@case4] = %case4 : <@BoolXor>, i1
      struct.writem %self[@case5] = %case5 : <@BoolXor>, i1
      struct.writem %self[@case6] = %case6 : <@BoolXor>, i1
      struct.writem %self[@case7] = %case7 : <@BoolXor>, i1
      struct.writem %self[@case8] = %case8 : <@BoolXor>, i1

      function.return %self : !struct.type<@BoolXor>
    }

    function.def @constrain(%self: !struct.type<@BoolXor>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @BoolXor StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(0)
// CHECK-NEXT:     %self[@case1] in Degenerate(1)
// CHECK-NEXT:     %self[@case2] in Degenerate(1)
// CHECK-NEXT:     %self[@case3] in Degenerate(0)
// CHECK-NEXT:     %self[@case4] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case5] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case6] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case7] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case8] in TypeA:[ 0, 1 ]
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  struct.def @BoolNot {
    struct.member @case0 : i1
    struct.member @case1 : i1
    struct.member @case2 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolNot> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@BoolNot>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.not %true
      %case1 = bool.not %false
      %case2 = bool.not %any

      struct.writem %self[@case0] = %case0 : <@BoolNot>, i1
      struct.writem %self[@case1] = %case1 : <@BoolNot>, i1
      struct.writem %self[@case2] = %case2 : <@BoolNot>, i1

      function.return %self : !struct.type<@BoolNot>
    }

    function.def @constrain(%self: !struct.type<@BoolNot>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @BoolNot StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(0)
// CHECK-NEXT:     %self[@case1] in Degenerate(1)
// CHECK-NEXT:     %self[@case2] in  TypeA:[ 0, 1 ]
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  struct.def @BitAnd {
    struct.member @case0 : !felt.type
    struct.member @case1 : !felt.type
    struct.member @case2 : !felt.type
    struct.member @case3 : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@BitAnd> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@BitAnd>

      %ff = felt.const 255 // 0xff
      %2 = felt.const 2

      %case0 = felt.bit_and %a, %b
      %case1 = felt.bit_and %a, %ff
      %case2 = felt.bit_and %ff, %a
      %case3 = felt.bit_and %2, %ff

      struct.writem %self[@case0] = %case0 : <@BitAnd>, !felt.type
      struct.writem %self[@case1] = %case1 : <@BitAnd>, !felt.type
      struct.writem %self[@case2] = %case2 : <@BitAnd>, !felt.type
      struct.writem %self[@case3] = %case3 : <@BitAnd>, !felt.type

      function.return %self : !struct.type<@BitAnd>
    }

    function.def @constrain(%self: !struct.type<@BitAnd>, %a: !felt.type, %b: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @BitAnd StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %self[@case0] in Entire
// CHECK-NEXT:     %self[@case1] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %self[@case2] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %self[@case3] in Degenerate(2)
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  struct.def @ShiftLeft {
    struct.member @case0 : !felt.type
    struct.member @case1 : !felt.type
    struct.member @case2 : !felt.type
    struct.member @case3 : !felt.type
    struct.member @case4 : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@ShiftLeft> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@ShiftLeft>

      %ff = felt.const 255 // 0xff
      %2 = felt.const 2

      %case0 = felt.shl %a, %b
      %case1 = felt.shl %a, %2
      %case2 = felt.shl %ff, %2
      %case3 = felt.shl %b, %ff
      %case4 = felt.shl %2, %ff

      struct.writem %self[@case0] = %case0 : <@ShiftLeft>, !felt.type
      struct.writem %self[@case1] = %case1 : <@ShiftLeft>, !felt.type
      struct.writem %self[@case2] = %case2 : <@ShiftLeft>, !felt.type
      struct.writem %self[@case3] = %case3 : <@ShiftLeft>, !felt.type
      struct.writem %self[@case4] = %case4 : <@ShiftLeft>, !felt.type

      function.return %self : !struct.type<@ShiftLeft>
    }

    function.def @constrain(%self: !struct.type<@ShiftLeft>, %a: !felt.type, %b: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @ShiftLeft StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %self[@case0] in Entire
// CHECK-NEXT:     %self[@case1] in Entire
// CHECK-NEXT:     %self[@case2] in Degenerate(1020)
// CHECK-NEXT:     %self[@case3] in Entire
// CHECK-NEXT:     %self[@case4] in Entire
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  struct.def @ShiftRight {
    struct.member @case0 : !felt.type
    struct.member @case1 : !felt.type
    struct.member @case2 : !felt.type
    struct.member @case3 : !felt.type
    struct.member @case4 : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@ShiftRight> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@ShiftRight>

      %ff = felt.const 255 // 0xff
      %2 = felt.const 2

      %case0 = felt.shr %a, %b
      %case1 = felt.shr %a, %2
      %case2 = felt.shr %ff, %2
      %case3 = felt.shr %b, %ff
      %case4 = felt.shr %2, %ff

      struct.writem %self[@case0] = %case0 : <@ShiftRight>, !felt.type
      struct.writem %self[@case1] = %case1 : <@ShiftRight>, !felt.type
      struct.writem %self[@case2] = %case2 : <@ShiftRight>, !felt.type
      struct.writem %self[@case3] = %case3 : <@ShiftRight>, !felt.type
      struct.writem %self[@case4] = %case4 : <@ShiftRight>, !felt.type

      function.return %self : !struct.type<@ShiftRight>
    }

    function.def @constrain(%self: !struct.type<@ShiftRight>, %a: !felt.type, %b: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @ShiftRight StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %self[@case0] in Entire
// CHECK-NEXT:     %self[@case1] in Entire
// CHECK-NEXT:     %self[@case2] in Degenerate(63)
// CHECK-NEXT:     %self[@case3] in Entire
// CHECK-NEXT:     %self[@case4] in Degenerate(0)
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  // yield-less if that modifies intervals internally
  struct.def @NoYieldIf {
    struct.member @data : !felt.type
    struct.member @const : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@NoYieldIf> {
      %self = struct.new : !struct.type<@NoYieldIf>
      %z = felt.const 0
      %0 = bool.cmp ne(%a, %z)
      scf.if %0 {
        struct.writem %self[@data] = %b : !struct.type<@NoYieldIf>, !felt.type
        struct.writem %self[@const] = %z : !struct.type<@NoYieldIf>, !felt.type
      }
      function.return %self : !struct.type<@NoYieldIf>
    }

    function.def @constrain(%self : !struct.type<@NoYieldIf>, %a: !felt.type, %b: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: @NoYieldIf StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %self[@data] in Entire
// CHECK-NEXT:     %self[@const] in Degenerate(0)
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  // A struct that stores if the input is 0 or not
  // to showcase `scf.if`.
  // Only constraints that the stored value is a boolean.
  // A real circuit would have more stuff
  struct.def @IsZero {
    struct.member @bit : !felt.type

    function.def @compute(%a: !felt.type) -> !struct.type<@IsZero> {
      %self = struct.new : !struct.type<@IsZero>
      %z = felt.const 0
      %b = bool.cmp eq(%a, %z)
      %0 = scf.if %b -> !felt.type {
        scf.yield %z : !felt.type
      } else {
        %2 = felt.const 1
        scf.yield %2 : !felt.type
      }
      struct.writem %self[@bit] = %0 : !struct.type<@IsZero>, !felt.type
      function.return %self : !struct.type<@IsZero>
    }

    function.def @constrain(%self : !struct.type<@IsZero>, %a: !felt.type) {
      %0 = struct.readm %self[@bit] : !struct.type<@IsZero>, !felt.type
      %1 = felt.const 1
      %2 = felt.sub %0, %1
      %3 = felt.mul %0, %2
      %4 = felt.const 0
      constrain.eq %3, %4 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL: @IsZero StructIntervals {
// CHECK-NEXT:     compute {
// CHECK-NEXT:         %arg0 in Entire
// CHECK-NEXT:         %self[@bit] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     }
// CHECK-NEXT:     constrain {
// CHECK-NEXT:         %arg0[@bit] in TypeA:[ 0, 1 ]
// CHECK-NEXT:         %arg1 in Entire
// CHECK-NEXT:     }
// CHECK-NEXT: }

// -----

module attributes {llzk.lang} {
  struct.def @MultiYield {
    struct.member @a : !felt.type
    struct.member @b : !felt.type
    struct.member @c : !felt.type

    function.def @compute(%in : !felt.type) -> !struct.type<@MultiYield> {
      %self = struct.new : !struct.type<@MultiYield>
      %z = felt.const 0
      %cmp = bool.cmp eq(%in, %z)
      %a, %b, %c = scf.if %cmp -> (!felt.type, !felt.type, !felt.type) {
        %0 = felt.const 1
        %1 = felt.const 2
        %2 = felt.const 3
        scf.yield %0, %1, %2 : !felt.type, !felt.type, !felt.type
      } else {
        %0 = felt.const 2
        %1 = felt.const 99
        scf.yield %0, %1, %in : !felt.type, !felt.type, !felt.type
      }
      struct.writem %self[@a] = %a : !struct.type<@MultiYield>, !felt.type
      struct.writem %self[@b] = %b : !struct.type<@MultiYield>, !felt.type
      struct.writem %self[@c] = %c : !struct.type<@MultiYield>, !felt.type
      function.return %self : !struct.type<@MultiYield>
    }

    function.def @constrain(%self : !struct.type<@MultiYield>, %in : !felt.type) {
      function.return
    }
  }
}
// CHECK-LABEL: @MultiYield StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:    %arg0 in Entire
// CHECK-NEXT:    %self[@a] in TypeA:[ 1, 2 ]
// CHECK-NEXT:    %self[@b] in TypeA:[ 2, 99 ]
// CHECK-NEXT:    %self[@c] in Entire
// CHECK-NEXT:  }

// -----

module attributes {llzk.lang} {
  struct.def @NoYieldFor {
    struct.member @a: !felt.type

    function.def @compute(%x: index) -> !struct.type<@NoYieldFor> {
      %self = struct.new : !struct.type<@NoYieldFor>
      %0 = arith.constant 0 : index
      %1 = arith.constant 1 : index
      scf.for %i = %0 to %x step %1 {
        %c = felt.const 3
        struct.writem %self[@a] = %c : !struct.type<@NoYieldFor>, !felt.type
      }
      function.return %self : !struct.type<@NoYieldFor>
    }

    function.def @constrain(%self: !struct.type<@NoYieldFor>, %x: index) {
      function.return
    }
  }
}
// CHECK-LABEL: @NoYieldFor StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:    %arg0 in Entire
// CHECK-NEXT:    %self[@a] in Degenerate(3)
// CHECK-NEXT:  }

// -----

module attributes {llzk.lang} {
  struct.def @YieldForConst {
    struct.member @a: !felt.type

    function.def @compute(%x: index) -> !struct.type<@YieldForConst> {
      %self = struct.new : !struct.type<@YieldForConst>
      %0 = arith.constant 0 : index
      %1 = arith.constant 1 : index
      %f0 = felt.const 0
      %c = scf.for %i = %0 to %x step %1 iter_args (%unused = %f0) -> (!felt.type) {
        %3 = felt.const 3
        scf.yield %3 : !felt.type
      }
      // COM: This is currently unsound, as it doesn't account for whether
      // or not the loop will run.
      struct.writem %self[@a] = %c : !struct.type<@YieldForConst>, !felt.type
      function.return %self : !struct.type<@YieldForConst>
    }

    function.def @constrain(%self: !struct.type<@YieldForConst>, %x: index) {
      function.return
    }
  }
}

// CHECK-LABEL: @YieldForConst StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:    %arg0 in Entire
// CHECK-NEXT:    %self[@a] in Degenerate(3)
// CHECK-NEXT:  }

// -----

module attributes {llzk.lang} {
  struct.def @YieldForConst {
    struct.member @a: !felt.type

    function.def @compute(%x: index) -> !struct.type<@YieldForConst> {
      %self = struct.new : !struct.type<@YieldForConst>
      %0 = arith.constant 0 : index
      %1 = arith.constant 1 : index
      %f0 = felt.const 0
      scf.for %i = %0 to %x step %1 {
        %3 = felt.const 3
        // COM: This is currently unsound, as it doesn't account for whether
        // or not the loop will run.
        struct.writem %self[@a] = %3 : !struct.type<@YieldForConst>, !felt.type
        scf.yield
      }
      function.return %self : !struct.type<@YieldForConst>
    }

    function.def @constrain(%self: !struct.type<@YieldForConst>, %x: index) {
      function.return
    }
  }
}

// CHECK-LABEL: @YieldForConst StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:    %arg0 in Entire
// CHECK-NEXT:    %self[@a] in Degenerate(3)
// CHECK-NEXT:  }

// -----

// No guesses will be made about the computed value over the loop
module attributes {llzk.lang} {
  struct.def @YieldForSum {
    struct.member @a: !felt.type

    function.def @compute(%x: index) -> !struct.type<@YieldForSum> {
      %self = struct.new : !struct.type<@YieldForSum>
      %0 = arith.constant 0 : index
      %1 = arith.constant 1 : index
      %f0 = felt.const 0
      %c = scf.for %i = %0 to %x step %1 iter_args (%sum = %f0) -> (!felt.type) {
        %f1 = felt.const 1
        %s = felt.add %f1, %sum
        scf.yield %s : !felt.type
      }
      struct.writem %self[@a] = %c : !struct.type<@YieldForSum>, !felt.type
      function.return %self : !struct.type<@YieldForSum>
    }

    function.def @constrain(%self: !struct.type<@YieldForSum>, %x: index) {
      function.return
    }
  }
}

// CHECK-LABEL: @YieldForSum StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:    %arg0 in Entire
// CHECK-NEXT:    %self[@a] in Entire
// CHECK-NEXT:  }

// -----

// COM: Regression test for convergence of the interval analysis.
module attributes {llzk.lang} {
  include.from "FrontendLang/Zirgen/Inputs/zir_example_loops.llzk" as @zir_loops
}

// -----

module attributes {llzk.lang} {
  struct.def @ConstBools {
    struct.member @out : i1
    function.def @compute() -> !struct.type<@ConstBools> attributes {function.allow_non_native_field_ops, function.allow_witness} {
      %self = struct.new : !struct.type<@ConstBools>
      %true = arith.constant true
      %false = arith.constant false
      %res = bool.and %true, %false
      struct.writem %self[@out] = %res : !struct.type<@ConstBools>, i1
      function.return %self : !struct.type<@ConstBools>
    }
    function.def @constrain(%arg0: !struct.type<@ConstBools>) attributes {function.allow_constraint} {
      function.return
    }
  }
}

// CHECK-LABEL: @ConstBools StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:    %self[@out] in Degenerate(0)
// CHECK-NEXT:  }

// -----

module attributes {llzk.lang} {
  struct.def @ArithConstraint {

    function.def @constrain(%self: !struct.type<@ArithConstraint>, %a: !felt.type, %b: !felt.type) {
      function.return
    }

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@ArithConstraint> attributes {function.allow_non_native_field_ops} {
      %self = struct.new : !struct.type<@ArithConstraint>

      %5 = felt.const 5
      %7 = felt.const 7
      %11 = felt.const 11
      %cmp1 = bool.cmp ge(%a, %5)
      bool.assert %cmp1
      %cmp2 = bool.cmp le(%a, %7)
      bool.assert %cmp2
      %cmp3 = bool.cmp gt(%b, %7)
      bool.assert %cmp3
      %cmp4 = bool.cmp le(%b, %11)
      bool.assert %cmp4

      %mul = felt.mul %a, %5
      %sub = felt.sub %mul, %5
      %1 = felt.div %11, %11
      %mod = felt.umod %sub, %b
      %neg = felt.neg %mod
      %final = felt.add %mul, %neg

      %0 = felt.const 0
      %notzero = bool.cmp ne(%final, %0)
      bool.assert %notzero

      function.return %self : !struct.type<@ArithConstraint>
    }
  }
}

// CHECK-LABEL: @ArithConstraint StructIntervals {
// CHECK-NEXT: compute {
// CHECK-NEXT:     %arg0 in TypeA:[ 5, 7 ]
// CHECK-NEXT:     %arg1 in TypeA:[ 8, 11 ]
// CHECK-NEXT: }
