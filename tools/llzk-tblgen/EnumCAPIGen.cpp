//===- EnumCAPIGen.cpp - C API generator for enum attributes --------------===//
//
// Part of the LLZK Project, under the Apache License v2.0.
// See LICENSE.txt for license information.
// Copyright 2025 Veridise Inc.
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
//
// EnumCAPIGen generates C API enum declarations from EnumAttr definitions
// in TableGen files. This allows exposing MLIR enum attributes to C APIs.
//
//===----------------------------------------------------------------------===//

#include <mlir/TableGen/Attribute.h>
#include <mlir/TableGen/GenInfo.h>

#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FormatVariadic.h>
#include <llvm/TableGen/Record.h>
#include <llvm/TableGen/TableGenBackend.h>

#include "CommonCAPIGen.h"

using namespace mlir;
using namespace mlir::tblgen;

namespace {

/// @brief Generator for enum C header files
struct EnumHeaderGenerator : public HeaderGenerator {
  using HeaderGenerator::HeaderGenerator;
  virtual ~EnumHeaderGenerator() = default;

  void setEnumName(StringRef enumCppNamespace, StringRef enumClassName) {
    std::string classNamePascal = toPascalCase(enumClassName);
    this->cEnumName = toPascalCase(FunctionPrefix) + toPascalCase(DialectName) + classNamePascal;
    this->cEnumAltName = toPascalCase(enumCppNamespace) + classNamePascal;
    // Reset case labels for next enum
    caseLabels.clear();
  }

  void genCaseLabel(const EnumAttrCase &enumCase) {
    static constexpr char fmt[] = "  {0}_{1} = {2}";
    assert(!cEnumName.empty() && "cEnumName must be set");
    this->caseLabels.push_back(
        llvm::formatv(fmt, cEnumName, enumCase.getSymbol().upper(), enumCase.getValue()).str()
    );
  }

  void genEnumDeclaration() const {
    static constexpr char fmt[] = R"(
enum {0} {{
{2}
};
// type name based on prefix + dialect + enum class name
typedef enum {0} {0};
// type name based on cpp namespace + enum class name
typedef enum {0} {1};
)";
    assert(!cEnumName.empty() && "cEnumName must be set");
    os << llvm::formatv(fmt, cEnumName, cEnumAltName, llvm::join(caseLabels, ",\n"));
  }

protected:
  std::string cEnumName;
  /// Alternative enum name based on C++ namespace. This is needed for cases that use
  /// the final line in `mapCppTypeToCapiType()` where the full C++ type with namespace
  /// is known but the dialect name and function prefix of that type are not.
  std::string cEnumAltName;
  /// Collects generated enum case labels until `genEnumDeclaration()` is called.
  SmallVector<std::string> caseLabels;
};

/// @brief Generator for enum C implementation files
struct EnumImplementationGenerator : public ImplementationGenerator {
  using ImplementationGenerator::ImplementationGenerator;
  virtual ~EnumImplementationGenerator() = default;

  void setEnumName(StringRef enumCppNamespace, StringRef enumClassName) {
    std::string classNamePascal = toPascalCase(enumClassName);
    this->cEnumName = toPascalCase(FunctionPrefix) + toPascalCase(DialectName) + classNamePascal;
  }

  /// @brief Generate 'wrap' and 'unwrap' functions for the enum type so the code generated by
  /// `genParameterGetterImplWrapped()` works for the enum type.
  void genWrapAndUnwrapDeclaration(StringRef enumCppNamespace, StringRef enumClassName) const {
    static constexpr char fmt[] = R"(
    static inline {0} wrap({1} cpp) {
      return {0}(cpp);
    }
    static inline {1} unwrap({0} c) {
      return {1}(c);
    }
    )";
    assert(!cEnumName.empty() && "cEnumName must be set");
    os << llvm::formatv(fmt, cEnumName, enumCppNamespace + "::" + enumClassName);
  }

protected:
  std::string cEnumName;
};

} // namespace

/// Emit C API header for enum attributes
static bool emitEnumCAPIHeader(const llvm::RecordKeeper &records, raw_ostream &os) {
  emitSourceFileHeader("Enum C API Declarations", os, records);

  EnumHeaderGenerator generator("Enum", os);
  generator.genPrologue();

  // Find all EnumAttr definitions
  for (const auto *def : records.getAllDerivedDefinitionsIfDefined("EnumAttrInfo")) {
    const EnumAttr enumInfo(def);
    StringRef enumCppNamespace = enumInfo.getCppNamespace();

    // Generate for the selected dialect only
    // EnumAttr does not contain a Dialect reference, so filter by C++ namespace instead.
    if (!DialectName.empty() && !enumCppNamespace.contains_insensitive(DialectName)) {
      continue;
    }

    std::vector<EnumAttrCase> enumCases = enumInfo.getAllCases();
    if (enumCases.empty()) {
      continue;
    }

    generator.setEnumName(enumCppNamespace, enumInfo.getEnumClassName());
    for (EnumAttrCase &enumCase : enumCases) {
      generator.genCaseLabel(enumCase);
    }
    generator.genEnumDeclaration();
  }

  generator.genEpilogue();
  return false;
}

/// Emit C API implementation for enum attributes
static bool emitEnumCAPIImpl(const llvm::RecordKeeper &records, raw_ostream &os) {
  emitSourceFileHeader("Enum C API Implementations", os, records);

  EnumImplementationGenerator generator("Enum", os);

  // Find all EnumAttr definitions
  for (const auto *def : records.getAllDerivedDefinitionsIfDefined("EnumAttrInfo")) {
    const EnumAttr enumInfo(def);
    StringRef enumCppNamespace = enumInfo.getCppNamespace();

    // Generate for the selected dialect only
    // EnumAttr does not contain a Dialect reference, so filter by C++ namespace instead.
    if (!DialectName.empty() && !enumCppNamespace.contains_insensitive(DialectName)) {
      continue;
    }

    std::vector<EnumAttrCase> enumCases = enumInfo.getAllCases();
    if (enumCases.empty()) {
      continue;
    }

    generator.setEnumName(enumCppNamespace, enumInfo.getEnumClassName());
    generator.genWrapAndUnwrapDeclaration(enumCppNamespace, enumInfo.getEnumClassName());
  }
  return false;
}

static mlir::GenRegistration genEnumCAPIHeader(
    "gen-enum-capi-header", "Generate C API enum declarations from EnumAttr definitions",
    &emitEnumCAPIHeader
);

static mlir::GenRegistration genEnumCAPIImpl(
    "gen-enum-capi-impl", "Generate enum C API wrap/unwrap implementations", &emitEnumCAPIImpl
);
